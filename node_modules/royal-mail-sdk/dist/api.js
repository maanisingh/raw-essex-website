"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Royal Mail API Shipping V3 (REST)
 * This API specification details the requirements for integrating with **Royal Mail API Shipping V3**.<br><br>It specifically covers how the Royal Mail API Shipping V3 can be used by business customers to conduct shipping activity with Royal Mail and provides the technical information to build this integration. This specification must be used with the relevant accompanying specifications for customers wishing to interface their systems with Royal Mail services.<br><br>Royal Mail API Shipping V3 exposes a fully RESTful service that allows account customers to create shipments, produce labels, and produce documentation for all the tasks required to ship domestic items with Royal Mail.<br><br>Built on industry standards, Royal Mail API Shipping V3 provides a simple and low cost method for customers to integrate with Royal Mail, and allows them to get shipping quickly. The API offers data streaming and offline barcoding to allow customers greater flexibility when generating their labels. There are no costs to customers for using the Royal Mail API Shipping V3 services, however customersâ€™ own development costs must be covered by the customer developing the solution. Royal Mail will not accept any responsibility for these development, implementation and testing costs. Customers should address initial enquiries regarding development of systems for these purposes to their account handler.<br><br>This API can be used in conjunction with Royal Mail Pro Shipping, a GUI based shipping platform. For more details on Royal Mail Pro Shipping, including videos on and briefs on updating/ cancelling a shipment and Manifesting please refer to http://www.royalmail.com/pro-shipping-help.
 *
 * The version of the OpenAPI document: 3.0.15
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenApi = exports.TokenApiFactory = exports.TokenApiFp = exports.TokenApiAxiosParamCreator = exports.ShipmentsApi = exports.ShipmentsApiFactory = exports.ShipmentsApiFp = exports.ShipmentsApiAxiosParamCreator = exports.PackagingApi = exports.PackagingApiFactory = exports.PackagingApiFp = exports.PackagingApiAxiosParamCreator = exports.ManifestsApi = exports.ManifestsApiFactory = exports.ManifestsApiFp = exports.ManifestsApiAxiosParamCreator = exports.ItemsApi = exports.ItemsApiFactory = exports.ItemsApiFp = exports.ItemsApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.ShipmentCreateResponseReturnLabelImageFormatEnum = exports.ShipmentCreateResponseLabelImageFormatEnum = exports.ShipmentCancelRequestReasonForCancellationEnum = exports.ServiceAvailabilityShipmentInformationProductEnum = exports.ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum = exports.ServiceAvailabilityServiceOptionsServiceFormatEnum = exports.ServiceAvailabilityResponseWeightUnitOfMeasureEnum = exports.ServiceAvailabilityFormatServiceFormatEnum = exports.PrintLabelResponseReturnLabelImageFormatEnum = exports.PrintLabelResponseLabelImageFormatEnum = exports.PrintLabelRequestLabelFormatEnum = exports.PrintDocumentResponseDocumentTypeEnum = exports.PrintDocumentRequestDocumentTypeEnum = exports.PackagingWeightUnitOfMeasureEnum = exports.ItemWeightUnitOfMeasureEnum = exports.CreateShipmentShipmentInformationShipmentActionEnum = exports.CreateShipmentShipmentInformationLabelFormatEnum = exports.CreateShipmentShipmentInformationProductEnum = exports.CreateShipmentShipmentInformationWeightUnitOfMeasureEnum = exports.CreateShipmentServiceOptionsTrackingNotificationsEnum = exports.CreateShipmentServiceOptionsConsequentialLossEnum = exports.CreateShipmentServiceOptionsServiceFormatEnum = void 0;
var globalImportUrl = require("url");
var axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
var base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var CreateShipmentServiceOptionsServiceFormatEnum;
(function (CreateShipmentServiceOptionsServiceFormatEnum) {
    CreateShipmentServiceOptionsServiceFormatEnum["L"] = "L";
    CreateShipmentServiceOptionsServiceFormatEnum["F"] = "F";
    CreateShipmentServiceOptionsServiceFormatEnum["P"] = "P";
    CreateShipmentServiceOptionsServiceFormatEnum["S"] = "S";
})(CreateShipmentServiceOptionsServiceFormatEnum = exports.CreateShipmentServiceOptionsServiceFormatEnum || (exports.CreateShipmentServiceOptionsServiceFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CreateShipmentServiceOptionsConsequentialLossEnum;
(function (CreateShipmentServiceOptionsConsequentialLossEnum) {
    CreateShipmentServiceOptionsConsequentialLossEnum["Level1"] = "Level1";
    CreateShipmentServiceOptionsConsequentialLossEnum["Level2"] = "Level2";
    CreateShipmentServiceOptionsConsequentialLossEnum["Level3"] = "Level3";
    CreateShipmentServiceOptionsConsequentialLossEnum["Level4"] = "Level4";
    CreateShipmentServiceOptionsConsequentialLossEnum["Level5"] = "Level5";
})(CreateShipmentServiceOptionsConsequentialLossEnum = exports.CreateShipmentServiceOptionsConsequentialLossEnum || (exports.CreateShipmentServiceOptionsConsequentialLossEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CreateShipmentServiceOptionsTrackingNotificationsEnum;
(function (CreateShipmentServiceOptionsTrackingNotificationsEnum) {
    CreateShipmentServiceOptionsTrackingNotificationsEnum["Email"] = "Email";
    CreateShipmentServiceOptionsTrackingNotificationsEnum["SMS"] = "SMS";
    CreateShipmentServiceOptionsTrackingNotificationsEnum["EmailAndSMS"] = "EmailAndSMS";
})(CreateShipmentServiceOptionsTrackingNotificationsEnum = exports.CreateShipmentServiceOptionsTrackingNotificationsEnum || (exports.CreateShipmentServiceOptionsTrackingNotificationsEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CreateShipmentShipmentInformationWeightUnitOfMeasureEnum;
(function (CreateShipmentShipmentInformationWeightUnitOfMeasureEnum) {
    CreateShipmentShipmentInformationWeightUnitOfMeasureEnum["KG"] = "KG";
    CreateShipmentShipmentInformationWeightUnitOfMeasureEnum["Grams"] = "Grams";
})(CreateShipmentShipmentInformationWeightUnitOfMeasureEnum = exports.CreateShipmentShipmentInformationWeightUnitOfMeasureEnum || (exports.CreateShipmentShipmentInformationWeightUnitOfMeasureEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CreateShipmentShipmentInformationProductEnum;
(function (CreateShipmentShipmentInformationProductEnum) {
    CreateShipmentShipmentInformationProductEnum["NDX"] = "NDX";
    CreateShipmentShipmentInformationProductEnum["DOX"] = "DOX";
})(CreateShipmentShipmentInformationProductEnum = exports.CreateShipmentShipmentInformationProductEnum || (exports.CreateShipmentShipmentInformationProductEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CreateShipmentShipmentInformationLabelFormatEnum;
(function (CreateShipmentShipmentInformationLabelFormatEnum) {
    CreateShipmentShipmentInformationLabelFormatEnum["PDF"] = "PDF";
    CreateShipmentShipmentInformationLabelFormatEnum["PNG"] = "PNG";
    CreateShipmentShipmentInformationLabelFormatEnum["DATASTREAM"] = "DATASTREAM";
    CreateShipmentShipmentInformationLabelFormatEnum["ZPL203DPI"] = "ZPL203DPI";
    CreateShipmentShipmentInformationLabelFormatEnum["ZPL300DPI"] = "ZPL300DPI";
})(CreateShipmentShipmentInformationLabelFormatEnum = exports.CreateShipmentShipmentInformationLabelFormatEnum || (exports.CreateShipmentShipmentInformationLabelFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CreateShipmentShipmentInformationShipmentActionEnum;
(function (CreateShipmentShipmentInformationShipmentActionEnum) {
    CreateShipmentShipmentInformationShipmentActionEnum["Process"] = "Process";
    CreateShipmentShipmentInformationShipmentActionEnum["Allocate"] = "Allocate";
    CreateShipmentShipmentInformationShipmentActionEnum["Create"] = "Create";
})(CreateShipmentShipmentInformationShipmentActionEnum = exports.CreateShipmentShipmentInformationShipmentActionEnum || (exports.CreateShipmentShipmentInformationShipmentActionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ItemWeightUnitOfMeasureEnum;
(function (ItemWeightUnitOfMeasureEnum) {
    ItemWeightUnitOfMeasureEnum["KG"] = "KG";
    ItemWeightUnitOfMeasureEnum["Grams"] = "Grams";
})(ItemWeightUnitOfMeasureEnum = exports.ItemWeightUnitOfMeasureEnum || (exports.ItemWeightUnitOfMeasureEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PackagingWeightUnitOfMeasureEnum;
(function (PackagingWeightUnitOfMeasureEnum) {
    PackagingWeightUnitOfMeasureEnum["KG"] = "KG";
    PackagingWeightUnitOfMeasureEnum["Grams"] = "Grams";
})(PackagingWeightUnitOfMeasureEnum = exports.PackagingWeightUnitOfMeasureEnum || (exports.PackagingWeightUnitOfMeasureEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PrintDocumentRequestDocumentTypeEnum;
(function (PrintDocumentRequestDocumentTypeEnum) {
    PrintDocumentRequestDocumentTypeEnum["CN23"] = "CN23";
    PrintDocumentRequestDocumentTypeEnum["CI"] = "CI";
    PrintDocumentRequestDocumentTypeEnum["P"] = "P";
})(PrintDocumentRequestDocumentTypeEnum = exports.PrintDocumentRequestDocumentTypeEnum || (exports.PrintDocumentRequestDocumentTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PrintDocumentResponseDocumentTypeEnum;
(function (PrintDocumentResponseDocumentTypeEnum) {
    PrintDocumentResponseDocumentTypeEnum["CN23"] = "CN23";
    PrintDocumentResponseDocumentTypeEnum["CI"] = "CI";
    PrintDocumentResponseDocumentTypeEnum["P"] = "P";
})(PrintDocumentResponseDocumentTypeEnum = exports.PrintDocumentResponseDocumentTypeEnum || (exports.PrintDocumentResponseDocumentTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PrintLabelRequestLabelFormatEnum;
(function (PrintLabelRequestLabelFormatEnum) {
    PrintLabelRequestLabelFormatEnum["PDF"] = "PDF";
    PrintLabelRequestLabelFormatEnum["PNG"] = "PNG";
    PrintLabelRequestLabelFormatEnum["DATASTREAM"] = "DATASTREAM";
    PrintLabelRequestLabelFormatEnum["ZPL203DPI"] = "ZPL203DPI";
    PrintLabelRequestLabelFormatEnum["ZPL300DPI"] = "ZPL300DPI";
})(PrintLabelRequestLabelFormatEnum = exports.PrintLabelRequestLabelFormatEnum || (exports.PrintLabelRequestLabelFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PrintLabelResponseLabelImageFormatEnum;
(function (PrintLabelResponseLabelImageFormatEnum) {
    PrintLabelResponseLabelImageFormatEnum["PDF"] = "PDF";
    PrintLabelResponseLabelImageFormatEnum["PNG"] = "PNG";
    PrintLabelResponseLabelImageFormatEnum["DATASTREAM"] = "DATASTREAM";
    PrintLabelResponseLabelImageFormatEnum["ZPL203DPI"] = "ZPL203DPI";
    PrintLabelResponseLabelImageFormatEnum["ZPL300DPI"] = "ZPL300DPI";
})(PrintLabelResponseLabelImageFormatEnum = exports.PrintLabelResponseLabelImageFormatEnum || (exports.PrintLabelResponseLabelImageFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PrintLabelResponseReturnLabelImageFormatEnum;
(function (PrintLabelResponseReturnLabelImageFormatEnum) {
    PrintLabelResponseReturnLabelImageFormatEnum["PDF"] = "PDF";
    PrintLabelResponseReturnLabelImageFormatEnum["PNG"] = "PNG";
    PrintLabelResponseReturnLabelImageFormatEnum["ZPL300DPI"] = "ZPL300DPI";
    PrintLabelResponseReturnLabelImageFormatEnum["ZPL203DPI"] = "ZPL203DPI";
})(PrintLabelResponseReturnLabelImageFormatEnum = exports.PrintLabelResponseReturnLabelImageFormatEnum || (exports.PrintLabelResponseReturnLabelImageFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ServiceAvailabilityFormatServiceFormatEnum;
(function (ServiceAvailabilityFormatServiceFormatEnum) {
    ServiceAvailabilityFormatServiceFormatEnum["L"] = "L";
    ServiceAvailabilityFormatServiceFormatEnum["F"] = "F";
    ServiceAvailabilityFormatServiceFormatEnum["P"] = "P";
    ServiceAvailabilityFormatServiceFormatEnum["S"] = "S";
})(ServiceAvailabilityFormatServiceFormatEnum = exports.ServiceAvailabilityFormatServiceFormatEnum || (exports.ServiceAvailabilityFormatServiceFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ServiceAvailabilityResponseWeightUnitOfMeasureEnum;
(function (ServiceAvailabilityResponseWeightUnitOfMeasureEnum) {
    ServiceAvailabilityResponseWeightUnitOfMeasureEnum["KG"] = "KG";
    ServiceAvailabilityResponseWeightUnitOfMeasureEnum["Grams"] = "Grams";
})(ServiceAvailabilityResponseWeightUnitOfMeasureEnum = exports.ServiceAvailabilityResponseWeightUnitOfMeasureEnum || (exports.ServiceAvailabilityResponseWeightUnitOfMeasureEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ServiceAvailabilityServiceOptionsServiceFormatEnum;
(function (ServiceAvailabilityServiceOptionsServiceFormatEnum) {
    ServiceAvailabilityServiceOptionsServiceFormatEnum["L"] = "L";
    ServiceAvailabilityServiceOptionsServiceFormatEnum["F"] = "F";
    ServiceAvailabilityServiceOptionsServiceFormatEnum["P"] = "P";
    ServiceAvailabilityServiceOptionsServiceFormatEnum["S"] = "S";
})(ServiceAvailabilityServiceOptionsServiceFormatEnum = exports.ServiceAvailabilityServiceOptionsServiceFormatEnum || (exports.ServiceAvailabilityServiceOptionsServiceFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum;
(function (ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum) {
    ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum["KG"] = "KG";
    ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum["Grams"] = "Grams";
})(ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum = exports.ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum || (exports.ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ServiceAvailabilityShipmentInformationProductEnum;
(function (ServiceAvailabilityShipmentInformationProductEnum) {
    ServiceAvailabilityShipmentInformationProductEnum["NDX"] = "NDX";
    ServiceAvailabilityShipmentInformationProductEnum["DOX"] = "DOX";
})(ServiceAvailabilityShipmentInformationProductEnum = exports.ServiceAvailabilityShipmentInformationProductEnum || (exports.ServiceAvailabilityShipmentInformationProductEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ShipmentCancelRequestReasonForCancellationEnum;
(function (ShipmentCancelRequestReasonForCancellationEnum) {
    ShipmentCancelRequestReasonForCancellationEnum["OrderCancelled"] = "OrderCancelled";
    ShipmentCancelRequestReasonForCancellationEnum["Repacked"] = "Repacked";
    ShipmentCancelRequestReasonForCancellationEnum["UploadedInError"] = "UploadedInError";
    ShipmentCancelRequestReasonForCancellationEnum["WrongService"] = "WrongService";
})(ShipmentCancelRequestReasonForCancellationEnum = exports.ShipmentCancelRequestReasonForCancellationEnum || (exports.ShipmentCancelRequestReasonForCancellationEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ShipmentCreateResponseLabelImageFormatEnum;
(function (ShipmentCreateResponseLabelImageFormatEnum) {
    ShipmentCreateResponseLabelImageFormatEnum["PDF"] = "PDF";
    ShipmentCreateResponseLabelImageFormatEnum["PNG"] = "PNG";
    ShipmentCreateResponseLabelImageFormatEnum["DATASTREAM"] = "DATASTREAM";
    ShipmentCreateResponseLabelImageFormatEnum["ZPL203DPI"] = "ZPL203DPI";
    ShipmentCreateResponseLabelImageFormatEnum["ZPL300DPI"] = "ZPL300DPI";
})(ShipmentCreateResponseLabelImageFormatEnum = exports.ShipmentCreateResponseLabelImageFormatEnum || (exports.ShipmentCreateResponseLabelImageFormatEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ShipmentCreateResponseReturnLabelImageFormatEnum;
(function (ShipmentCreateResponseReturnLabelImageFormatEnum) {
    ShipmentCreateResponseReturnLabelImageFormatEnum["PDF"] = "PDF";
    ShipmentCreateResponseReturnLabelImageFormatEnum["PNG"] = "PNG";
    ShipmentCreateResponseReturnLabelImageFormatEnum["ZPL300DPI"] = "ZPL300DPI";
    ShipmentCreateResponseReturnLabelImageFormatEnum["ZPL203DPI"] = "ZPL203DPI";
})(ShipmentCreateResponseReturnLabelImageFormatEnum = exports.ShipmentCreateResponseReturnLabelImageFormatEnum || (exports.ShipmentCreateResponseReturnLabelImageFormatEnum = {}));
/**
 * AddressesApi - axios parameter creator
 * @export
 */
exports.AddressesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Add a new address to your address book that you can then use in your shipment requests.
         * @summary Create Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Address} address The address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesCreate: function (xRMGAuthToken, address, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling addressesCreate.');
                            }
                            // verify required parameter 'address' is not null or undefined
                            if (address === null || address === undefined) {
                                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling addressesCreate.');
                            }
                            localVarPath = "/addresses";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified address.
         * @summary Delete Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesDelete: function (xRMGAuthToken, addressId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling addressesDelete.');
                            }
                            // verify required parameter 'addressId' is not null or undefined
                            if (addressId === null || addressId === undefined) {
                                throw new base_1.RequiredError('addressId', 'Required parameter addressId was null or undefined when calling addressesDelete.');
                            }
                            localVarPath = "/addresses/{addressId}"
                                .replace("{" + "addressId" + "}", encodeURIComponent(String(addressId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get the address specified by your unique Address ID.
         * @summary Get Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGet: function (xRMGAuthToken, addressId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling addressesGet.');
                            }
                            // verify required parameter 'addressId' is not null or undefined
                            if (addressId === null || addressId === undefined) {
                                throw new base_1.RequiredError('addressId', 'Required parameter addressId was null or undefined when calling addressesGet.');
                            }
                            localVarPath = "/addresses/{addressId}"
                                .replace("{" + "addressId" + "}", encodeURIComponent(String(addressId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get all of your stored addresses
         * @summary Get Addresses
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGetAll: function (xRMGAuthToken, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling addressesGetAll.');
                            }
                            localVarPath = "/addresses";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
         * @summary Update address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to update.
         * @param {Address} address The address with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesUpdate: function (xRMGAuthToken, addressId, address, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling addressesUpdate.');
                            }
                            // verify required parameter 'addressId' is not null or undefined
                            if (addressId === null || addressId === undefined) {
                                throw new base_1.RequiredError('addressId', 'Required parameter addressId was null or undefined when calling addressesUpdate.');
                            }
                            // verify required parameter 'address' is not null or undefined
                            if (address === null || address === undefined) {
                                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling addressesUpdate.');
                            }
                            localVarPath = "/addresses/{addressId}"
                                .replace("{" + "addressId" + "}", encodeURIComponent(String(addressId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
exports.AddressesApiFp = function (configuration) {
    return {
        /**
         * Add a new address to your address book that you can then use in your shipment requests.
         * @summary Create Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Address} address The address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesCreate: function (xRMGAuthToken, address, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.AddressesApiAxiosParamCreator(configuration).addressesCreate(xRMGAuthToken, address, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified address.
         * @summary Delete Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesDelete: function (xRMGAuthToken, addressId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.AddressesApiAxiosParamCreator(configuration).addressesDelete(xRMGAuthToken, addressId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get the address specified by your unique Address ID.
         * @summary Get Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGet: function (xRMGAuthToken, addressId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.AddressesApiAxiosParamCreator(configuration).addressesGet(xRMGAuthToken, addressId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get all of your stored addresses
         * @summary Get Addresses
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGetAll: function (xRMGAuthToken, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.AddressesApiAxiosParamCreator(configuration).addressesGetAll(xRMGAuthToken, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
         * @summary Update address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to update.
         * @param {Address} address The address with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesUpdate: function (xRMGAuthToken, addressId, address, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.AddressesApiAxiosParamCreator(configuration).addressesUpdate(xRMGAuthToken, addressId, address, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * AddressesApi - factory interface
 * @export
 */
exports.AddressesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add a new address to your address book that you can then use in your shipment requests.
         * @summary Create Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Address} address The address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesCreate: function (xRMGAuthToken, address, options) {
            return exports.AddressesApiFp(configuration).addressesCreate(xRMGAuthToken, address, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the specified address.
         * @summary Delete Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesDelete: function (xRMGAuthToken, addressId, options) {
            return exports.AddressesApiFp(configuration).addressesDelete(xRMGAuthToken, addressId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the address specified by your unique Address ID.
         * @summary Get Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGet: function (xRMGAuthToken, addressId, options) {
            return exports.AddressesApiFp(configuration).addressesGet(xRMGAuthToken, addressId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get all of your stored addresses
         * @summary Get Addresses
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGetAll: function (xRMGAuthToken, options) {
            return exports.AddressesApiFp(configuration).addressesGetAll(xRMGAuthToken, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
         * @summary Update address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to update.
         * @param {Address} address The address with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesUpdate: function (xRMGAuthToken, addressId, address, options) {
            return exports.AddressesApiFp(configuration).addressesUpdate(xRMGAuthToken, addressId, address, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
var AddressesApi = /** @class */ (function (_super) {
    __extends(AddressesApi, _super);
    function AddressesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Add a new address to your address book that you can then use in your shipment requests.
     * @summary Create Address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Address} address The address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    AddressesApi.prototype.addressesCreate = function (xRMGAuthToken, address, options) {
        var _this = this;
        return exports.AddressesApiFp(this.configuration).addressesCreate(xRMGAuthToken, address, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the specified address.
     * @summary Delete Address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} addressId Your unique Address ID of the address to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    AddressesApi.prototype.addressesDelete = function (xRMGAuthToken, addressId, options) {
        var _this = this;
        return exports.AddressesApiFp(this.configuration).addressesDelete(xRMGAuthToken, addressId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the address specified by your unique Address ID.
     * @summary Get Address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} addressId Your unique Address ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    AddressesApi.prototype.addressesGet = function (xRMGAuthToken, addressId, options) {
        var _this = this;
        return exports.AddressesApiFp(this.configuration).addressesGet(xRMGAuthToken, addressId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get all of your stored addresses
     * @summary Get Addresses
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    AddressesApi.prototype.addressesGetAll = function (xRMGAuthToken, options) {
        var _this = this;
        return exports.AddressesApiFp(this.configuration).addressesGetAll(xRMGAuthToken, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
     * @summary Update address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} addressId Your unique Address ID of the address to update.
     * @param {Address} address The address with the updated details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    AddressesApi.prototype.addressesUpdate = function (xRMGAuthToken, addressId, address, options) {
        var _this = this;
        return exports.AddressesApiFp(this.configuration).addressesUpdate(xRMGAuthToken, addressId, address, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AddressesApi;
}(base_1.BaseAPI));
exports.AddressesApi = AddressesApi;
/**
 * ItemsApi - axios parameter creator
 * @export
 */
exports.ItemsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Add a new item to your stored items that you can then use in your shipment requests.
         * @summary Create Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Item} item The item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCreate: function (xRMGAuthToken, item, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling itemsCreate.');
                            }
                            // verify required parameter 'item' is not null or undefined
                            if (item === null || item === undefined) {
                                throw new base_1.RequiredError('item', 'Required parameter item was null or undefined when calling itemsCreate.');
                            }
                            localVarPath = "/items";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof item !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(item !== undefined ? item : {}) : (item || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified item.
         * @summary Delete Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsDelete: function (xRMGAuthToken, itemId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling itemsDelete.');
                            }
                            // verify required parameter 'itemId' is not null or undefined
                            if (itemId === null || itemId === undefined) {
                                throw new base_1.RequiredError('itemId', 'Required parameter itemId was null or undefined when calling itemsDelete.');
                            }
                            localVarPath = "/items/{itemId}"
                                .replace("{" + "itemId" + "}", encodeURIComponent(String(itemId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get the item specified by your unique Item ID.
         * @summary Get Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGet: function (xRMGAuthToken, itemId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling itemsGet.');
                            }
                            // verify required parameter 'itemId' is not null or undefined
                            if (itemId === null || itemId === undefined) {
                                throw new base_1.RequiredError('itemId', 'Required parameter itemId was null or undefined when calling itemsGet.');
                            }
                            localVarPath = "/items/{itemId}"
                                .replace("{" + "itemId" + "}", encodeURIComponent(String(itemId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get all of your stored items
         * @summary Get Items
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGetAll: function (xRMGAuthToken, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling itemsGetAll.');
                            }
                            localVarPath = "/items";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update an item that is already stored with new details. The whole item will be replaced with new details.
         * @summary Update item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to update.
         * @param {Item} item The item with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsUpdate: function (xRMGAuthToken, itemId, item, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling itemsUpdate.');
                            }
                            // verify required parameter 'itemId' is not null or undefined
                            if (itemId === null || itemId === undefined) {
                                throw new base_1.RequiredError('itemId', 'Required parameter itemId was null or undefined when calling itemsUpdate.');
                            }
                            // verify required parameter 'item' is not null or undefined
                            if (item === null || item === undefined) {
                                throw new base_1.RequiredError('item', 'Required parameter item was null or undefined when calling itemsUpdate.');
                            }
                            localVarPath = "/items/{itemId}"
                                .replace("{" + "itemId" + "}", encodeURIComponent(String(itemId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof item !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(item !== undefined ? item : {}) : (item || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * ItemsApi - functional programming interface
 * @export
 */
exports.ItemsApiFp = function (configuration) {
    return {
        /**
         * Add a new item to your stored items that you can then use in your shipment requests.
         * @summary Create Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Item} item The item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCreate: function (xRMGAuthToken, item, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ItemsApiAxiosParamCreator(configuration).itemsCreate(xRMGAuthToken, item, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified item.
         * @summary Delete Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsDelete: function (xRMGAuthToken, itemId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ItemsApiAxiosParamCreator(configuration).itemsDelete(xRMGAuthToken, itemId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get the item specified by your unique Item ID.
         * @summary Get Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGet: function (xRMGAuthToken, itemId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ItemsApiAxiosParamCreator(configuration).itemsGet(xRMGAuthToken, itemId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get all of your stored items
         * @summary Get Items
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGetAll: function (xRMGAuthToken, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ItemsApiAxiosParamCreator(configuration).itemsGetAll(xRMGAuthToken, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Update an item that is already stored with new details. The whole item will be replaced with new details.
         * @summary Update item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to update.
         * @param {Item} item The item with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsUpdate: function (xRMGAuthToken, itemId, item, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ItemsApiAxiosParamCreator(configuration).itemsUpdate(xRMGAuthToken, itemId, item, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * ItemsApi - factory interface
 * @export
 */
exports.ItemsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add a new item to your stored items that you can then use in your shipment requests.
         * @summary Create Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Item} item The item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCreate: function (xRMGAuthToken, item, options) {
            return exports.ItemsApiFp(configuration).itemsCreate(xRMGAuthToken, item, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the specified item.
         * @summary Delete Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsDelete: function (xRMGAuthToken, itemId, options) {
            return exports.ItemsApiFp(configuration).itemsDelete(xRMGAuthToken, itemId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the item specified by your unique Item ID.
         * @summary Get Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGet: function (xRMGAuthToken, itemId, options) {
            return exports.ItemsApiFp(configuration).itemsGet(xRMGAuthToken, itemId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get all of your stored items
         * @summary Get Items
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGetAll: function (xRMGAuthToken, options) {
            return exports.ItemsApiFp(configuration).itemsGetAll(xRMGAuthToken, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update an item that is already stored with new details. The whole item will be replaced with new details.
         * @summary Update item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to update.
         * @param {Item} item The item with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsUpdate: function (xRMGAuthToken, itemId, item, options) {
            return exports.ItemsApiFp(configuration).itemsUpdate(xRMGAuthToken, itemId, item, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
var ItemsApi = /** @class */ (function (_super) {
    __extends(ItemsApi, _super);
    function ItemsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Add a new item to your stored items that you can then use in your shipment requests.
     * @summary Create Item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Item} item The item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    ItemsApi.prototype.itemsCreate = function (xRMGAuthToken, item, options) {
        var _this = this;
        return exports.ItemsApiFp(this.configuration).itemsCreate(xRMGAuthToken, item, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the specified item.
     * @summary Delete Item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} itemId Your unique Item ID of the item to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    ItemsApi.prototype.itemsDelete = function (xRMGAuthToken, itemId, options) {
        var _this = this;
        return exports.ItemsApiFp(this.configuration).itemsDelete(xRMGAuthToken, itemId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the item specified by your unique Item ID.
     * @summary Get Item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} itemId Your unique Item ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    ItemsApi.prototype.itemsGet = function (xRMGAuthToken, itemId, options) {
        var _this = this;
        return exports.ItemsApiFp(this.configuration).itemsGet(xRMGAuthToken, itemId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get all of your stored items
     * @summary Get Items
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    ItemsApi.prototype.itemsGetAll = function (xRMGAuthToken, options) {
        var _this = this;
        return exports.ItemsApiFp(this.configuration).itemsGetAll(xRMGAuthToken, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update an item that is already stored with new details. The whole item will be replaced with new details.
     * @summary Update item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} itemId Your unique Item ID of the item to update.
     * @param {Item} item The item with the updated details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    ItemsApi.prototype.itemsUpdate = function (xRMGAuthToken, itemId, item, options) {
        var _this = this;
        return exports.ItemsApiFp(this.configuration).itemsUpdate(xRMGAuthToken, itemId, item, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ItemsApi;
}(base_1.BaseAPI));
exports.ItemsApi = ItemsApi;
/**
 * ManifestsApi - axios parameter creator
 * @export
 */
exports.ManifestsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest All Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreate: function (xRMGAuthToken, request, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling manifestsCreate.');
                            }
                            // verify required parameter 'request' is not null or undefined
                            if (request === null || request === undefined) {
                                throw new base_1.RequiredError('request', 'Required parameter request was null or undefined when calling manifestsCreate.');
                            }
                            localVarPath = "/manifests";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Carrier Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestCarrierCodesRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByCarrier: function (xRMGAuthToken, request, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling manifestsCreateByCarrier.');
                            }
                            // verify required parameter 'request' is not null or undefined
                            if (request === null || request === undefined) {
                                throw new base_1.RequiredError('request', 'Required parameter request was null or undefined when calling manifestsCreateByCarrier.');
                            }
                            localVarPath = "/manifests/bycarrier";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Service Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestServiceCodesRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByService: function (xRMGAuthToken, request, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling manifestsCreateByService.');
                            }
                            // verify required parameter 'request' is not null or undefined
                            if (request === null || request === undefined) {
                                throw new base_1.RequiredError('request', 'Required parameter request was null or undefined when calling manifestsCreateByService.');
                            }
                            localVarPath = "/manifests/byservice";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * ManifestsApi - functional programming interface
 * @export
 */
exports.ManifestsApiFp = function (configuration) {
    return {
        /**
         * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest All Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreate: function (xRMGAuthToken, request, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ManifestsApiAxiosParamCreator(configuration).manifestsCreate(xRMGAuthToken, request, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Carrier Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestCarrierCodesRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByCarrier: function (xRMGAuthToken, request, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ManifestsApiAxiosParamCreator(configuration).manifestsCreateByCarrier(xRMGAuthToken, request, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Service Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestServiceCodesRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByService: function (xRMGAuthToken, request, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ManifestsApiAxiosParamCreator(configuration).manifestsCreateByService(xRMGAuthToken, request, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * ManifestsApi - factory interface
 * @export
 */
exports.ManifestsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest All Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreate: function (xRMGAuthToken, request, options) {
            return exports.ManifestsApiFp(configuration).manifestsCreate(xRMGAuthToken, request, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Carrier Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestCarrierCodesRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByCarrier: function (xRMGAuthToken, request, options) {
            return exports.ManifestsApiFp(configuration).manifestsCreateByCarrier(xRMGAuthToken, request, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Service Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestServiceCodesRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByService: function (xRMGAuthToken, request, options) {
            return exports.ManifestsApiFp(configuration).manifestsCreateByService(xRMGAuthToken, request, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * ManifestsApi - object-oriented interface
 * @export
 * @class ManifestsApi
 * @extends {BaseAPI}
 */
var ManifestsApi = /** @class */ (function (_super) {
    __extends(ManifestsApi, _super);
    function ManifestsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
     * @summary Manifest All Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ManifestRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    ManifestsApi.prototype.manifestsCreate = function (xRMGAuthToken, request, options) {
        var _this = this;
        return exports.ManifestsApiFp(this.configuration).manifestsCreate(xRMGAuthToken, request, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
     * @summary Manifest by Carrier Code(s)
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ManifestCarrierCodesRequest} request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    ManifestsApi.prototype.manifestsCreateByCarrier = function (xRMGAuthToken, request, options) {
        var _this = this;
        return exports.ManifestsApiFp(this.configuration).manifestsCreateByCarrier(xRMGAuthToken, request, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
     * @summary Manifest by Service Code(s)
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ManifestServiceCodesRequest} request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    ManifestsApi.prototype.manifestsCreateByService = function (xRMGAuthToken, request, options) {
        var _this = this;
        return exports.ManifestsApiFp(this.configuration).manifestsCreateByService(xRMGAuthToken, request, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ManifestsApi;
}(base_1.BaseAPI));
exports.ManifestsApi = ManifestsApi;
/**
 * PackagingApi - axios parameter creator
 * @export
 */
exports.PackagingApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Add new packaging to your stored packaging details that you can then use in your shipment requests.
         * @summary Create Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Packaging} packaging The packaging details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingCreate: function (xRMGAuthToken, packaging, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling packagingCreate.');
                            }
                            // verify required parameter 'packaging' is not null or undefined
                            if (packaging === null || packaging === undefined) {
                                throw new base_1.RequiredError('packaging', 'Required parameter packaging was null or undefined when calling packagingCreate.');
                            }
                            localVarPath = "/packaging";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof packaging !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(packaging !== undefined ? packaging : {}) : (packaging || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified packaging.
         * @summary Delete Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingDelete: function (xRMGAuthToken, packagingId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling packagingDelete.');
                            }
                            // verify required parameter 'packagingId' is not null or undefined
                            if (packagingId === null || packagingId === undefined) {
                                throw new base_1.RequiredError('packagingId', 'Required parameter packagingId was null or undefined when calling packagingDelete.');
                            }
                            localVarPath = "/packaging/{packagingId}"
                                .replace("{" + "packagingId" + "}", encodeURIComponent(String(packagingId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get the packaging details specified by your unique Packaging ID.
         * @summary Get Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your Unique Packaging ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGet: function (xRMGAuthToken, packagingId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling packagingGet.');
                            }
                            // verify required parameter 'packagingId' is not null or undefined
                            if (packagingId === null || packagingId === undefined) {
                                throw new base_1.RequiredError('packagingId', 'Required parameter packagingId was null or undefined when calling packagingGet.');
                            }
                            localVarPath = "/packaging/{packagingId}"
                                .replace("{" + "packagingId" + "}", encodeURIComponent(String(packagingId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get all of your stored packaging details
         * @summary Get All Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGetAll: function (xRMGAuthToken, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling packagingGetAll.');
                            }
                            localVarPath = "/packaging";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update packaging details that is already stored with new details. All details will be replaced with new details.
         * @summary Update packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
         * @param {Packaging} packaging The packaging with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingUpdate: function (xRMGAuthToken, packagingId, packaging, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling packagingUpdate.');
                            }
                            // verify required parameter 'packagingId' is not null or undefined
                            if (packagingId === null || packagingId === undefined) {
                                throw new base_1.RequiredError('packagingId', 'Required parameter packagingId was null or undefined when calling packagingUpdate.');
                            }
                            // verify required parameter 'packaging' is not null or undefined
                            if (packaging === null || packaging === undefined) {
                                throw new base_1.RequiredError('packaging', 'Required parameter packaging was null or undefined when calling packagingUpdate.');
                            }
                            localVarPath = "/packaging/{packagingId}"
                                .replace("{" + "packagingId" + "}", encodeURIComponent(String(packagingId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof packaging !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(packaging !== undefined ? packaging : {}) : (packaging || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * PackagingApi - functional programming interface
 * @export
 */
exports.PackagingApiFp = function (configuration) {
    return {
        /**
         * Add new packaging to your stored packaging details that you can then use in your shipment requests.
         * @summary Create Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Packaging} packaging The packaging details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingCreate: function (xRMGAuthToken, packaging, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.PackagingApiAxiosParamCreator(configuration).packagingCreate(xRMGAuthToken, packaging, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified packaging.
         * @summary Delete Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingDelete: function (xRMGAuthToken, packagingId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.PackagingApiAxiosParamCreator(configuration).packagingDelete(xRMGAuthToken, packagingId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get the packaging details specified by your unique Packaging ID.
         * @summary Get Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your Unique Packaging ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGet: function (xRMGAuthToken, packagingId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.PackagingApiAxiosParamCreator(configuration).packagingGet(xRMGAuthToken, packagingId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Get all of your stored packaging details
         * @summary Get All Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGetAll: function (xRMGAuthToken, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.PackagingApiAxiosParamCreator(configuration).packagingGetAll(xRMGAuthToken, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Update packaging details that is already stored with new details. All details will be replaced with new details.
         * @summary Update packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
         * @param {Packaging} packaging The packaging with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingUpdate: function (xRMGAuthToken, packagingId, packaging, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.PackagingApiAxiosParamCreator(configuration).packagingUpdate(xRMGAuthToken, packagingId, packaging, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * PackagingApi - factory interface
 * @export
 */
exports.PackagingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Add new packaging to your stored packaging details that you can then use in your shipment requests.
         * @summary Create Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Packaging} packaging The packaging details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingCreate: function (xRMGAuthToken, packaging, options) {
            return exports.PackagingApiFp(configuration).packagingCreate(xRMGAuthToken, packaging, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the specified packaging.
         * @summary Delete Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingDelete: function (xRMGAuthToken, packagingId, options) {
            return exports.PackagingApiFp(configuration).packagingDelete(xRMGAuthToken, packagingId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the packaging details specified by your unique Packaging ID.
         * @summary Get Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your Unique Packaging ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGet: function (xRMGAuthToken, packagingId, options) {
            return exports.PackagingApiFp(configuration).packagingGet(xRMGAuthToken, packagingId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get all of your stored packaging details
         * @summary Get All Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGetAll: function (xRMGAuthToken, options) {
            return exports.PackagingApiFp(configuration).packagingGetAll(xRMGAuthToken, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update packaging details that is already stored with new details. All details will be replaced with new details.
         * @summary Update packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
         * @param {Packaging} packaging The packaging with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingUpdate: function (xRMGAuthToken, packagingId, packaging, options) {
            return exports.PackagingApiFp(configuration).packagingUpdate(xRMGAuthToken, packagingId, packaging, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * PackagingApi - object-oriented interface
 * @export
 * @class PackagingApi
 * @extends {BaseAPI}
 */
var PackagingApi = /** @class */ (function (_super) {
    __extends(PackagingApi, _super);
    function PackagingApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Add new packaging to your stored packaging details that you can then use in your shipment requests.
     * @summary Create Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Packaging} packaging The packaging details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    PackagingApi.prototype.packagingCreate = function (xRMGAuthToken, packaging, options) {
        var _this = this;
        return exports.PackagingApiFp(this.configuration).packagingCreate(xRMGAuthToken, packaging, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the specified packaging.
     * @summary Delete Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    PackagingApi.prototype.packagingDelete = function (xRMGAuthToken, packagingId, options) {
        var _this = this;
        return exports.PackagingApiFp(this.configuration).packagingDelete(xRMGAuthToken, packagingId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the packaging details specified by your unique Packaging ID.
     * @summary Get Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} packagingId Your Unique Packaging ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    PackagingApi.prototype.packagingGet = function (xRMGAuthToken, packagingId, options) {
        var _this = this;
        return exports.PackagingApiFp(this.configuration).packagingGet(xRMGAuthToken, packagingId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get all of your stored packaging details
     * @summary Get All Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    PackagingApi.prototype.packagingGetAll = function (xRMGAuthToken, options) {
        var _this = this;
        return exports.PackagingApiFp(this.configuration).packagingGetAll(xRMGAuthToken, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update packaging details that is already stored with new details. All details will be replaced with new details.
     * @summary Update packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
     * @param {Packaging} packaging The packaging with the updated details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    PackagingApi.prototype.packagingUpdate = function (xRMGAuthToken, packagingId, packaging, options) {
        var _this = this;
        return exports.PackagingApiFp(this.configuration).packagingUpdate(xRMGAuthToken, packagingId, packaging, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PackagingApi;
}(base_1.BaseAPI));
exports.PackagingApi = PackagingApi;
/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
exports.ShipmentsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
         * @summary Cancel Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCancel: function (xRMGAuthToken, shipmentCancelRequests, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsCancel.');
                            }
                            // verify required parameter 'shipmentCancelRequests' is not null or undefined
                            if (shipmentCancelRequests === null || shipmentCancelRequests === undefined) {
                                throw new base_1.RequiredError('shipmentCancelRequests', 'Required parameter shipmentCancelRequests was null or undefined when calling shipmentsCancel.');
                            }
                            localVarPath = "/shipments/cancel";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof shipmentCancelRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(shipmentCancelRequests !== undefined ? shipmentCancelRequests : {}) : (shipmentCancelRequests || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
         * @summary Create Shipment
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {CreateShipmentShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCreate: function (xRMGAuthToken, shipment, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsCreate.');
                            }
                            // verify required parameter 'shipment' is not null or undefined
                            if (shipment === null || shipment === undefined) {
                                throw new base_1.RequiredError('shipment', 'Required parameter shipment was null or undefined when calling shipmentsCreate.');
                            }
                            localVarPath = "/shipments";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof shipment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(shipment !== undefined ? shipment : {}) : (shipment || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
         * @summary Defer Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsDefer: function (xRMGAuthToken, shipmentDeferRequests, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsDefer.');
                            }
                            // verify required parameter 'shipmentDeferRequests' is not null or undefined
                            if (shipmentDeferRequests === null || shipmentDeferRequests === undefined) {
                                throw new base_1.RequiredError('shipmentDeferRequests', 'Required parameter shipmentDeferRequests was null or undefined when calling shipmentsDefer.');
                            }
                            localVarPath = "/shipments/defer";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof shipmentDeferRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(shipmentDeferRequests !== undefined ? shipmentDeferRequests : {}) : (shipmentDeferRequests || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
         * @summary Hold Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsHold: function (xRMGAuthToken, shipmentHoldRequests, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsHold.');
                            }
                            // verify required parameter 'shipmentHoldRequests' is not null or undefined
                            if (shipmentHoldRequests === null || shipmentHoldRequests === undefined) {
                                throw new base_1.RequiredError('shipmentHoldRequests', 'Required parameter shipmentHoldRequests was null or undefined when calling shipmentsHold.');
                            }
                            localVarPath = "/shipments/hold";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof shipmentHoldRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(shipmentHoldRequests !== undefined ? shipmentHoldRequests : {}) : (shipmentHoldRequests || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
         * @summary Print Document
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintDocument: function (xRMGAuthToken, shipmentId, printDocumentRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsPrintDocument.');
                            }
                            // verify required parameter 'shipmentId' is not null or undefined
                            if (shipmentId === null || shipmentId === undefined) {
                                throw new base_1.RequiredError('shipmentId', 'Required parameter shipmentId was null or undefined when calling shipmentsPrintDocument.');
                            }
                            // verify required parameter 'printDocumentRequest' is not null or undefined
                            if (printDocumentRequest === null || printDocumentRequest === undefined) {
                                throw new base_1.RequiredError('printDocumentRequest', 'Required parameter printDocumentRequest was null or undefined when calling shipmentsPrintDocument.');
                            }
                            localVarPath = "/shipments/{shipmentId}/printDocument"
                                .replace("{" + "shipmentId" + "}", encodeURIComponent(String(shipmentId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof printDocumentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(printDocumentRequest !== undefined ? printDocumentRequest : {}) : (printDocumentRequest || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
         * @summary Print Label
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintLabelRequest} printLabelRequest Print Label Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintLabel: function (xRMGAuthToken, shipmentId, printLabelRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsPrintLabel.');
                            }
                            // verify required parameter 'shipmentId' is not null or undefined
                            if (shipmentId === null || shipmentId === undefined) {
                                throw new base_1.RequiredError('shipmentId', 'Required parameter shipmentId was null or undefined when calling shipmentsPrintLabel.');
                            }
                            // verify required parameter 'printLabelRequest' is not null or undefined
                            if (printLabelRequest === null || printLabelRequest === undefined) {
                                throw new base_1.RequiredError('printLabelRequest', 'Required parameter printLabelRequest was null or undefined when calling shipmentsPrintLabel.');
                            }
                            localVarPath = "/shipments/{shipmentId}/printLabel"
                                .replace("{" + "shipmentId" + "}", encodeURIComponent(String(shipmentId)));
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof printLabelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(printLabelRequest !== undefined ? printLabelRequest : {}) : (printLabelRequest || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
         * @summary Release Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsRelease: function (xRMGAuthToken, shipmentsReleaseRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsRelease.');
                            }
                            // verify required parameter 'shipmentsReleaseRequest' is not null or undefined
                            if (shipmentsReleaseRequest === null || shipmentsReleaseRequest === undefined) {
                                throw new base_1.RequiredError('shipmentsReleaseRequest', 'Required parameter shipmentsReleaseRequest was null or undefined when calling shipmentsRelease.');
                            }
                            localVarPath = "/shipments/release";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof shipmentsReleaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(shipmentsReleaseRequest !== undefined ? shipmentsReleaseRequest : {}) : (shipmentsReleaseRequest || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
         * @summary Service Availability
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ServiceAvailabilityShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsServiceAvailability: function (xRMGAuthToken, shipment, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // verify required parameter 'xRMGAuthToken' is not null or undefined
                            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                                throw new base_1.RequiredError('xRMGAuthToken', 'Required parameter xRMGAuthToken was null or undefined when calling shipmentsServiceAvailability.');
                            }
                            // verify required parameter 'shipment' is not null or undefined
                            if (shipment === null || shipment === undefined) {
                                throw new base_1.RequiredError('shipment', 'Required parameter shipment was null or undefined when calling shipmentsServiceAvailability.');
                            }
                            localVarPath = "/shipments/serviceAvailability";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _b.label = 5;
                        case 5:
                            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            needsSerialization = (typeof shipment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
                            localVarRequestOptions.data = needsSerialization ? JSON.stringify(shipment !== undefined ? shipment : {}) : (shipment || "");
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * ShipmentsApi - functional programming interface
 * @export
 */
exports.ShipmentsApiFp = function (configuration) {
    return {
        /**
         * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
         * @summary Cancel Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCancel: function (xRMGAuthToken, shipmentCancelRequests, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsCancel(xRMGAuthToken, shipmentCancelRequests, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
         * @summary Create Shipment
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {CreateShipmentShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCreate: function (xRMGAuthToken, shipment, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsCreate(xRMGAuthToken, shipment, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
         * @summary Defer Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsDefer: function (xRMGAuthToken, shipmentDeferRequests, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsDefer(xRMGAuthToken, shipmentDeferRequests, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
         * @summary Hold Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsHold: function (xRMGAuthToken, shipmentHoldRequests, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsHold(xRMGAuthToken, shipmentHoldRequests, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
         * @summary Print Document
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintDocument: function (xRMGAuthToken, shipmentId, printDocumentRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsPrintDocument(xRMGAuthToken, shipmentId, printDocumentRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
         * @summary Print Label
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintLabelRequest} printLabelRequest Print Label Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintLabel: function (xRMGAuthToken, shipmentId, printLabelRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsPrintLabel(xRMGAuthToken, shipmentId, printLabelRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
         * @summary Release Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsRelease: function (xRMGAuthToken, shipmentsReleaseRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsRelease(xRMGAuthToken, shipmentsReleaseRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
         * @summary Service Availability
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ServiceAvailabilityShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsServiceAvailability: function (xRMGAuthToken, shipment, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.ShipmentsApiAxiosParamCreator(configuration).shipmentsServiceAvailability(xRMGAuthToken, shipment, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * ShipmentsApi - factory interface
 * @export
 */
exports.ShipmentsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
         * @summary Cancel Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCancel: function (xRMGAuthToken, shipmentCancelRequests, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsCancel(xRMGAuthToken, shipmentCancelRequests, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
         * @summary Create Shipment
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {CreateShipmentShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCreate: function (xRMGAuthToken, shipment, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsCreate(xRMGAuthToken, shipment, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
         * @summary Defer Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsDefer: function (xRMGAuthToken, shipmentDeferRequests, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsDefer(xRMGAuthToken, shipmentDeferRequests, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
         * @summary Hold Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsHold: function (xRMGAuthToken, shipmentHoldRequests, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsHold(xRMGAuthToken, shipmentHoldRequests, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
         * @summary Print Document
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintDocument: function (xRMGAuthToken, shipmentId, printDocumentRequest, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsPrintDocument(xRMGAuthToken, shipmentId, printDocumentRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
         * @summary Print Label
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintLabelRequest} printLabelRequest Print Label Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintLabel: function (xRMGAuthToken, shipmentId, printLabelRequest, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsPrintLabel(xRMGAuthToken, shipmentId, printLabelRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
         * @summary Release Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsRelease: function (xRMGAuthToken, shipmentsReleaseRequest, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsRelease(xRMGAuthToken, shipmentsReleaseRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
         * @summary Service Availability
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ServiceAvailabilityShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsServiceAvailability: function (xRMGAuthToken, shipment, options) {
            return exports.ShipmentsApiFp(configuration).shipmentsServiceAvailability(xRMGAuthToken, shipment, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
var ShipmentsApi = /** @class */ (function (_super) {
    __extends(ShipmentsApi, _super);
    function ShipmentsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
     * @summary Cancel Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsCancel = function (xRMGAuthToken, shipmentCancelRequests, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsCancel(xRMGAuthToken, shipmentCancelRequests, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
     * @summary Create Shipment
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {CreateShipmentShipment} shipment The shipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsCreate = function (xRMGAuthToken, shipment, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsCreate(xRMGAuthToken, shipment, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
     * @summary Defer Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsDefer = function (xRMGAuthToken, shipmentDeferRequests, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsDefer(xRMGAuthToken, shipmentDeferRequests, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
     * @summary Hold Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsHold = function (xRMGAuthToken, shipmentHoldRequests, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsHold(xRMGAuthToken, shipmentHoldRequests, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
     * @summary Print Document
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
     * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsPrintDocument = function (xRMGAuthToken, shipmentId, printDocumentRequest, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsPrintDocument(xRMGAuthToken, shipmentId, printDocumentRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
     * @summary Print Label
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
     * @param {PrintLabelRequest} printLabelRequest Print Label Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsPrintLabel = function (xRMGAuthToken, shipmentId, printLabelRequest, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsPrintLabel(xRMGAuthToken, shipmentId, printLabelRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
     * @summary Release Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsRelease = function (xRMGAuthToken, shipmentsReleaseRequest, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsRelease(xRMGAuthToken, shipmentsReleaseRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
     * @summary Service Availability
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ServiceAvailabilityShipment} shipment The shipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    ShipmentsApi.prototype.shipmentsServiceAvailability = function (xRMGAuthToken, shipment, options) {
        var _this = this;
        return exports.ShipmentsApiFp(this.configuration).shipmentsServiceAvailability(xRMGAuthToken, shipment, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ShipmentsApi;
}(base_1.BaseAPI));
exports.ShipmentsApi = ShipmentsApi;
/**
 * TokenApi - axios parameter creator
 * @export
 */
exports.TokenApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Provides security token.
         * @summary Authenticates a User and provides token.
         * @param {string} xRMGSecurityUsername User Name
         * @param {string} xRMGSecurityPassword Password in plain text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost: function (xRMGSecurityUsername, xRMGSecurityPassword, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarApiKeyValue, _a, localVarApiKeyValue, _b, headersFromBaseOptions;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            // verify required parameter 'xRMGSecurityUsername' is not null or undefined
                            if (xRMGSecurityUsername === null || xRMGSecurityUsername === undefined) {
                                throw new base_1.RequiredError('xRMGSecurityUsername', 'Required parameter xRMGSecurityUsername was null or undefined when calling authenticatePost.');
                            }
                            // verify required parameter 'xRMGSecurityPassword' is not null or undefined
                            if (xRMGSecurityPassword === null || xRMGSecurityPassword === undefined) {
                                throw new base_1.RequiredError('xRMGSecurityPassword', 'Required parameter xRMGSecurityPassword was null or undefined when calling authenticatePost.');
                            }
                            localVarPath = "/token";
                            localVarUrlObj = globalImportUrl.parse(localVarPath, true);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 5];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 2];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Id")];
                        case 1:
                            _a = _c.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, configuration.apiKey];
                        case 3:
                            _a = _c.sent();
                            _c.label = 4;
                        case 4:
                            localVarApiKeyValue = _a;
                            localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
                            _c.label = 5;
                        case 5:
                            if (!(configuration && configuration.apiKey)) return [3 /*break*/, 10];
                            if (!(typeof configuration.apiKey === 'function')) return [3 /*break*/, 7];
                            return [4 /*yield*/, configuration.apiKey("X-IBM-Client-Secret")];
                        case 6:
                            _b = _c.sent();
                            return [3 /*break*/, 9];
                        case 7: return [4 /*yield*/, configuration.apiKey];
                        case 8:
                            _b = _c.sent();
                            _c.label = 9;
                        case 9:
                            localVarApiKeyValue = _b;
                            localVarHeaderParameter["X-IBM-Client-Secret"] = localVarApiKeyValue;
                            _c.label = 10;
                        case 10:
                            if (xRMGSecurityUsername !== undefined && xRMGSecurityUsername !== null) {
                                localVarHeaderParameter['X-RMG-Security-Username'] = String(xRMGSecurityUsername);
                            }
                            if (xRMGSecurityPassword !== undefined && xRMGSecurityPassword !== null) {
                                localVarHeaderParameter['X-RMG-Security-Password'] = String(xRMGSecurityPassword);
                            }
                            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
                            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
                            delete localVarUrlObj.search;
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: globalImportUrl.format(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * TokenApi - functional programming interface
 * @export
 */
exports.TokenApiFp = function (configuration) {
    return {
        /**
         * Provides security token.
         * @summary Authenticates a User and provides token.
         * @param {string} xRMGSecurityUsername User Name
         * @param {string} xRMGSecurityPassword Password in plain text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost: function (xRMGSecurityUsername, xRMGSecurityPassword, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, exports.TokenApiAxiosParamCreator(configuration).authenticatePost(xRMGSecurityUsername, xRMGSecurityPassword, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, function (axios, basePath) {
                                    if (axios === void 0) { axios = axios_1.default; }
                                    if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                                    var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                                    return axios.request(axiosRequestArgs);
                                }];
                    }
                });
            });
        },
    };
};
/**
 * TokenApi - factory interface
 * @export
 */
exports.TokenApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Provides security token.
         * @summary Authenticates a User and provides token.
         * @param {string} xRMGSecurityUsername User Name
         * @param {string} xRMGSecurityPassword Password in plain text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost: function (xRMGSecurityUsername, xRMGSecurityPassword, options) {
            return exports.TokenApiFp(configuration).authenticatePost(xRMGSecurityUsername, xRMGSecurityPassword, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
var TokenApi = /** @class */ (function (_super) {
    __extends(TokenApi, _super);
    function TokenApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Provides security token.
     * @summary Authenticates a User and provides token.
     * @param {string} xRMGSecurityUsername User Name
     * @param {string} xRMGSecurityPassword Password in plain text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    TokenApi.prototype.authenticatePost = function (xRMGSecurityUsername, xRMGSecurityPassword, options) {
        var _this = this;
        return exports.TokenApiFp(this.configuration).authenticatePost(xRMGSecurityUsername, xRMGSecurityPassword, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return TokenApi;
}(base_1.BaseAPI));
exports.TokenApi = TokenApi;
